import { promises as fs } from 'fs';
import path from 'path';
import { parse, stringify } from 'smol-toml';
import * as dotenv from 'dotenv';
import { AiToolsConfig, defaultConfig } from '../types/config.js';
import { UIHelper } from './ui.js';
import chalk from 'chalk';

export class ConfigManager {
  private static CONFIG_DIR = '.aitools';
  private static CONFIG_FILENAME = 'config.toml';
  private static GLOBAL_CONFIG_PATH = path.join(process.env.HOME || '', '.aitools', 'config.toml');
  
  private config: AiToolsConfig | null = null;
  private configPath: string | null = null;

  /**
   * Load configuration from file
   * Priority (highest to lowest):
   * 1. System environment variables (already in process.env)
   * 2. .env.local (project-specific, not in git)
   * 3. .env (project defaults, can be in git)
   * 4. Project config (.aitools/config.toml)
   * 5. Global config (~/.aitools/config.toml)
   * 6. Default config
   */
  async load(): Promise<AiToolsConfig> {
    // Load .env files in correct order (lower priority first, so they get overridden)
    await this.loadEnvFiles();
    let mergedConfig = { ...defaultConfig };
    
    // First, load global config if exists
    if (await this.fileExists(ConfigManager.GLOBAL_CONFIG_PATH)) {
      const globalConfig = await this.loadConfigFile(ConfigManager.GLOBAL_CONFIG_PATH);
      mergedConfig = this.deepMerge(mergedConfig, globalConfig);
    }

    // Then, load project config if exists (overrides global)
    const projectConfigPath = await this.findProjectConfig();
    if (projectConfigPath) {
      const projectConfig = await this.loadConfigFile(projectConfigPath);
      mergedConfig = this.deepMerge(mergedConfig, projectConfig);
      this.configPath = projectConfigPath; // Set path to project config
    } else if (await this.fileExists(ConfigManager.GLOBAL_CONFIG_PATH)) {
      this.configPath = ConfigManager.GLOBAL_CONFIG_PATH; // Fall back to global path
    }

    this.config = mergedConfig;
    return this.config;
  }

  /**
   * Deep merge two objects, with source overriding target
   */
  private deepMerge(target: any, source: any): any {
    const result = { ...target };
    
    for (const key in source) {
      if (source[key] !== undefined && source[key] !== null) {
        if (typeof source[key] === 'object' && !Array.isArray(source[key])) {
          result[key] = this.deepMerge(result[key] || {}, source[key]);
        } else {
          result[key] = source[key];
        }
      }
    }
    
    return result;
  }

  /**
   * Save configuration to file
   */
  async save(config: AiToolsConfig, global: boolean = false): Promise<void> {
    const targetPath = global 
      ? ConfigManager.GLOBAL_CONFIG_PATH 
      : path.join(process.cwd(), ConfigManager.CONFIG_DIR, ConfigManager.CONFIG_FILENAME);

    // Ensure directory exists
    const dir = path.dirname(targetPath);
    await fs.mkdir(dir, { recursive: true });

    // Now we save API keys to the config file since it's in .gitignore
    const configToSave = { ...config };

    // Organize config into proper sections
    const organizedConfig = this.organizeConfig(configToSave);
    const tomlContent = this.generateOrganizedToml(organizedConfig);

    // Add header comment with environment variable documentation
    const content = `# AI Tools Configuration
# Generated by: ai init
# Docs: https://github.com/dreamerhyde/aitools
#
# Environment Variables Loading Order (highest to lowest priority):
# 1. System environment variables
# 2. .env.local (local overrides, git-ignored)
# 3. .env (project defaults)
# 4. This config file
# 5. Global config (~/.aitools/config.toml)
#
# API keys support env() syntax:
# - env(VAR_NAME) - Use environment variable
# - env(VAR_NAME, "default") - With fallback value

${tomlContent}`;

    await fs.writeFile(targetPath, content, 'utf-8');
    this.configPath = targetPath;
    this.config = config;
  }

  /**
   * Get current configuration
   */
  get(): AiToolsConfig {
    return this.config || defaultConfig;
  }

  /**
   * Get current configuration (alias for get())
   */
  getConfig(): AiToolsConfig {
    return this.get();
  }

  /**
   * Check if the current config is global
   */
  isGlobalConfig(): boolean {
    return this.configPath === ConfigManager.GLOBAL_CONFIG_PATH;
  }

  /**
   * Get specific config value
   */
  getValue<K extends keyof AiToolsConfig>(key: K): AiToolsConfig[K] {
    const config = this.get();
    
    // Check environment variables for sensitive data
    if (key === 'openai_api_key' && !config.openai_api_key) {
      return process.env.OPENAI_API_KEY as AiToolsConfig[K];
    }
    if (key === 'slack_webhook_url' && !config.slack_webhook_url) {
      return process.env.SLACK_WEBHOOK_URL as AiToolsConfig[K];
    }
    
    return config[key];
  }

  /**
   * Update specific config value
   */
  async updateValue<K extends keyof AiToolsConfig>(key: K, value: AiToolsConfig[K]): Promise<void> {
    const config = this.get();
    config[key] = value;
    
    if (this.configPath) {
      const isGlobal = this.configPath === ConfigManager.GLOBAL_CONFIG_PATH;
      await this.save(config, isGlobal);
    }
  }

  /**
   * Check if config file exists
   * @param checkGlobal - if false, only check for project config
   */
  async hasConfig(checkGlobal: boolean = true): Promise<boolean> {
    const projectConfig = await this.findProjectConfig();
    if (projectConfig) return true;
    
    if (checkGlobal) {
      const globalConfig = await this.fileExists(ConfigManager.GLOBAL_CONFIG_PATH);
      return globalConfig;
    }
    
    return false;
  }

  /**
   * Get config file path
   */
  getConfigPath(): string | null {
    return this.configPath;
  }

  private async findProjectConfig(): Promise<string | null> {
    let currentDir = process.cwd();
    const root = path.parse(currentDir).root;

    while (currentDir !== root) {
      const configPath = path.join(currentDir, ConfigManager.CONFIG_DIR, ConfigManager.CONFIG_FILENAME);
      if (await this.fileExists(configPath)) {
        return configPath;
      }
      currentDir = path.dirname(currentDir);
    }

    return null;
  }

  private async loadConfigFile(filePath: string): Promise<AiToolsConfig> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const config = parse(content) as AiToolsConfig;
      
      // Process environment variable references
      const processedConfig = this.processEnvVars(config);
      
      // Merge with default config to ensure all fields exist
      return { ...defaultConfig, ...processedConfig };
    } catch (error) {
      UIHelper.showError(`Failed to load config from ${filePath}`);
      return defaultConfig;
    }
  }

  /**
   * Organize config into proper sections for better TOML structure
   */
  private organizeConfig(config: AiToolsConfig): any {
    const organized: any = {};
    
    // [general] section
    organized.general = {
      auto_update: config.auto_update,
      completion: config.completion,
      model: config.model
    };
    
    // [api] section - API keys and integrations
    organized.api = {};
    if (config.openai_api_key !== undefined) {
      organized.api.openai_api_key = config.openai_api_key;
    }
    if (config.slack_webhook_url !== undefined) {
      organized.api.slack_webhook_url = config.slack_webhook_url;
    }
    
    // [quality] section - Code quality rules
    organized.quality = {
      line_limit: config.line_limit,
      lint_on_hook: config.lint_on_hook,
      lines_on_hook: config.lines_on_hook
    };
    
    // [hooks] section
    if (config.hooks) {
      organized.hooks = config.hooks;
    }
    
    // [readme] section
    if (config.readme) {
      organized.readme = config.readme;
    }
    
    // [notifications] section
    if (config.notifications) {
      organized.notifications = config.notifications;
    }
    
    return organized;
  }

  /**
   * Generate organized TOML with proper sections and comments
   */
  private generateOrganizedToml(organized: any): string {
    let toml = '';
    
    // [general] section
    if (organized.general) {
      toml += '# General Settings\n[general]\n';
      for (const [key, value] of Object.entries(organized.general)) {
        if (value !== undefined) {
          toml += `${key} = ${JSON.stringify(value)}\n`;
        }
      }
      toml += '\n';
    }
    
    // [api] section
    if (organized.api && Object.keys(organized.api).length > 0) {
      toml += '# API Keys and Integrations\n';
      toml += '# Recommended: Use environment variables for sensitive data\n';
      toml += '[api]\n';
      for (const [key, value] of Object.entries(organized.api)) {
        if (value !== undefined) {
          // Special handling for env() syntax - don't double-quote
          if (typeof value === 'string' && value.startsWith('env(')) {
            toml += `${key} = "${value}"\n`;
          } else {
            toml += `${key} = ${JSON.stringify(value)}\n`;
          }
        }
      }
      toml += '\n';
    }
    
    // [quality] section
    if (organized.quality) {
      toml += '# Code Quality Rules\n[quality]\n';
      for (const [key, value] of Object.entries(organized.quality)) {
        if (value !== undefined) {
          toml += `${key} = ${JSON.stringify(value)}\n`;
        }
      }
      toml += '\n';
    }
    
    // Other sections - use standard TOML stringify with spacing
    const remainingSections = ['hooks', 'readme', 'notifications'];
    for (const section of remainingSections) {
      if (organized[section]) {
        const sectionToml = stringify({ [section]: organized[section] });
        if (sectionToml.trim()) {
          toml += `# ${section.charAt(0).toUpperCase() + section.slice(1)} Settings\n`;
          toml += sectionToml;
          if (!sectionToml.endsWith('\n')) toml += '\n';
          toml += '\n'; // Add extra blank line between sections
        }
      }
    }
    
    // Remove trailing blank lines but keep spacing between sections
    return toml.replace(/\n\n+$/, '\n');
  }

  /**
   * Process environment variable references in config values
   * Supports syntax: "env(VAR_NAME)" or "env(VAR_NAME, default_value)"
   */
  private processEnvVars(config: any): any {
    const envPattern = /^env\(([^,)]+)(?:,\s*(.+))?\)$/;
    
    const processValue = (value: any): any => {
      if (typeof value === 'string') {
        const match = value.match(envPattern);
        if (match) {
          const [, envVar, defaultValue] = match;
          const envValue = process.env[envVar.trim()];
          if (envValue !== undefined) {
            return envValue;
          }
          if (defaultValue !== undefined) {
            // Remove quotes if present
            return defaultValue.trim().replace(/^["']|["']$/g, '');
          }
          return undefined; // No env var and no default
        }
      } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        const processed: any = {};
        for (const key in value) {
          processed[key] = processValue(value[key]);
        }
        return processed;
      }
      return value;
    };
    
    return processValue(config);
  }

  /**
   * Load .env files following Next.js/Vercel best practices
   * 
   * Uses "stop at first found" logic - once a variable is found,
   * we don't override it from lower priority sources.
   * 
   * Loading order (highest to lowest priority):
   * 1. process.env (system environment variables)
   * 2. .env.local (local overrides, ignored by git)  
   * 3. .env (shared project defaults)
   * 
   * This matches Next.js behavior exactly.
   */
  private async loadEnvFiles(): Promise<void> {
    const cwd = process.cwd();
    const NODE_ENV = process.env.NODE_ENV || 'development';
    
    // Define loading order (highest priority first)
    // We check these in order and stop when we find each variable
    const envFiles = [
      // Note: process.env is already loaded (highest priority)
      NODE_ENV !== 'test' && '.env.local',  // .env.local is ignored in test
      '.env',
    ].filter(Boolean) as string[];
    
    // Parse all env files but don't load them yet
    const parsedEnvs: Record<string, Record<string, string>> = {};
    
    for (const fileName of envFiles) {
      const filePath = path.join(cwd, fileName);
      if (await this.fileExists(filePath)) {
        try {
          const content = await fs.readFile(filePath, 'utf-8');
          parsedEnvs[fileName] = dotenv.parse(content);
        } catch (error) {
          // Silently skip files that can't be read
        }
      }
    }
    
    // Now apply "stop at first found" logic
    // For each possible env var, find it in priority order
    const allKeys = new Set<string>();
    for (const env of Object.values(parsedEnvs)) {
      Object.keys(env).forEach(key => allKeys.add(key));
    }
    
    // For each key, use the highest priority value found
    for (const key of allKeys) {
      // Skip if already in process.env (system env has highest priority)
      if (process.env[key] !== undefined) {
        continue;
      }
      
      // Check each file in priority order
      for (const fileName of envFiles) {
        if (parsedEnvs[fileName]?.[key] !== undefined) {
          // Found it! Use this value and stop looking
          process.env[key] = parsedEnvs[fileName][key];
          break; // Stop at first found
        }
      }
    }
  }

  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}